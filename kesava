import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkcalendar import DateEntry
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.edge.options import Options as EdgeOptions
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    StaleElementReferenceException, 
    NoSuchElementException, 
    TimeoutException, 
    ElementClickInterceptedException,
    WebDriverException
)
import threading
import re
import time
import json
import os
import logging
from datetime import datetime, timedelta
import schedule
import random
try:
    from playsound import playsound
    SOUND_AVAILABLE = True
except ImportError:
    SOUND_AVAILABLE = False
try:
    import GPUtil
    GPU_AVAILABLE = True
except ImportError:
    GPU_AVAILABLE = False

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("slot_booking.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("SlotBooker")

# Global variables
slot_list = []
active_threads = []
active_drivers = []
scheduled_time = None
is_running = False
notification_enabled = True
config_file = "slot_config.json"
theme_var = None
notification_var = None
retry_count_var = None
booking_history = []

def check_gpu_availability():
    """Check if a GPU is available and return appropriate browser options."""
    if GPU_AVAILABLE:
        try:
            gpus = GPUtil.getGPUs()
            if gpus and any(gpu.load < 0.8 for gpu in gpus):  # Check if GPU is not heavily utilized
                logger.info("GPU detected and available.")
                return True, "--enable-gpu"
            else:
                logger.info("No available GPU or GPU fully utilized. Falling back to CPU.")
                return False, "--disable-gpu"
        except Exception as e:
            logger.error(f"Error checking GPU: {e}. Falling back to CPU.")
            return False, "--disable-gpu"
    else:
        logger.info("GPUtil not installed. Falling back to CPU.")
        return False, "--disable-gpu"

def show_notification(title, message, is_error=False):
    """Show notification to user and log it"""
    if notification_enabled:
        if is_error:
            messagebox.showerror(title, message)
        else:
            messagebox.showinfo(title, message)
    logger.info(f"Notification: {title} - {message}")

def slot_booking_process(username_input, password_input, day, date, start_time, end_time, 
                        scheduler_url, proxy, headless, browser_choice, root, continuous=False):
    global is_running
    driver = None
    attempt_count = 0
    max_retries = retry_count_var.get()
    
    try:
        # Check GPU availability
        use_gpu, gpu_arg = check_gpu_availability()
        root.after(0, lambda: status_label.config(text=f"Using {'GPU' if use_gpu else 'CPU'} | Finding slot: {date} {start_time}-{end_time}"))

        # Set up browser options based on user selection
        if browser_choice == "Chrome":
            options = ChromeOptions()
            if headless:
                options.add_argument("--headless=new")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
            options.add_argument(gpu_arg)  # GPU or CPU setting
            options.add_argument("--page-load-strategy=eager")
            options.add_argument("--disable-popup-blocking")
            options.add_argument("--disable-notifications")
            options.add_argument("--blink-settings=imagesEnabled=false")  # Disable images for faster loading
            
            if proxy:
                options.add_argument(f'--proxy-server={proxy}')
                
            # Add user agent rotation
            user_agents = [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
            ]
            options.add_argument(f"--user-agent={random.choice(user_agents)}")
            
            driver = webdriver.Chrome(options=options)
        elif browser_choice == "Firefox":
            options = FirefoxOptions()
            if headless:
                options.add_argument("--headless")
            
            # Optimize Firefox for performance
            options.set_preference("browser.tabs.remote.autostart", False)
            options.set_preference("browser.tabs.remote.autostart.2", False)
            options.set_preference("dom.ipc.processCount", 1)
            options.set_preference("browser.cache.disk.enable", False)
            options.set_preference("browser.cache.memory.enable", True)
            options.set_preference("browser.cache.memory.capacity", 65536)
            options.set_preference("permissions.default.image", 2)  # Disable images
            
            if proxy:
                proxy_host, proxy_port = proxy.split(':')
                options.set_preference("network.proxy.type", 1)
                options.set_preference("network.proxy.http", proxy_host)
                options.set_preference("network.proxy.http_port", int(proxy_port))
                options.set_preference("network.proxy.ssl", proxy_host)
                options.set_preference("network.proxy.ssl_port", int(proxy_port))
            
            driver = webdriver.Firefox(options=options)
        elif browser_choice == "Edge":
            options = EdgeOptions()
            if headless:
                options.add_argument("--headless")
            options.add_argument("--disable-extensions")
            options.add_argument("--disable-gpu" if not use_gpu else "--enable-gpu")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--disable-browser-side-navigation")
            options.add_argument("--disable-features=VizDisplayCompositor")
            
            if proxy:
                options.add_argument(f'--proxy-server={proxy}')
            
            driver = webdriver.Edge(options=options)
        else:
            raise ValueError("Unsupported browser selected")

        # Track the driver
        active_drivers.append(driver)
        driver.set_window_size(1366, 768)
        logger.info(f"Running in {browser_choice} {'headless' if headless else 'visible'} mode with {'GPU' if use_gpu else 'CPU'}")
        driver.implicitly_wait(1)

        # Login
        logger.info("Navigating to login page")
        driver.get("https://lms2.ai.saveetha.in/course/view.php?id=302")
        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.NAME, 'username'))).send_keys(username_input)
        driver.find_element(By.NAME, 'password').send_keys(password_input)
        driver.find_element(By.ID, 'loginbtn').click()
        
        # Check for login error
        try:
            error_message = WebDriverWait(driver, 2).until(EC.presence_of_element_located((By.CLASS_NAME, 'loginerrors')))
            error_text = error_message.text
            logger.error(f"Login failed: {error_text}")
            root.after(0, lambda: show_notification("Login Error", f"Failed to login: {error_text}", is_error=True))
            return
        except TimeoutException:
            # No error message found, login successful
            logger.info("Logged in successfully")

        # Parse the date to match LMS format
        try:
            date_obj = datetime.strptime(date.strip(), "%d %m %Y")
            formatted_date = date_obj.strftime("%d %B %Y")
        except ValueError:
            logger.error(f"Invalid date format: {date}")
            root.after(0, lambda: show_notification("Error", f"❌ Invalid date format: {date}", is_error=True))
            return

        # Try different date formats to match LMS
        expected_date_formats = [
            formatted_date,
            date_obj.strftime("%B %d, %Y"),
            date_obj.strftime("%d/%m/%Y"),
            f"{day.strip()}, {formatted_date}",
            f"{day.strip()}, {date_obj.strftime('%B %d, %Y')}"
        ]
        logger.info(f"Looking for slot with date in formats: {expected_date_formats}, time: {start_time}-{end_time}")

        # Slot finding with continuous refresh in headless mode
        found_slot = False
        max_attempts = max_retries if not continuous else float('inf')
        attempt = 0
        refresh_interval = 2  # Initial refresh interval
        
        while attempt < max_attempts and not found_slot and is_running:
            attempt += 1
            attempt_count += 1
            logger.info(f"Attempt {attempt}/{max_attempts if max_attempts != float('inf') else 'infinity'} to find and book slot")
            root.after(0, lambda: status_label.config(text=f"Attempt {attempt} | Finding slot: {date} {start_time}-{end_time}"))

            try:
                # Navigate to scheduler with error handling
                driver.get(scheduler_url)
                try:
                    WebDriverWait(driver, 8).until(EC.presence_of_element_located((By.ID, 'slotbookertable')))
                    logger.info("Scheduler page loaded")
                except TimeoutException:
                    logger.warning("Scheduler table not found, checking if we need to navigate to appointment page first")
                    # Check if we need to click 'Add appointment' first
                    try:
                        add_appt_button = WebDriverWait(driver, 3).until(
                            EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'Add appointment') or contains(text(), 'Book slot')]"))
                        )
                        add_appt_button.click()
                        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.ID, 'slotbookertable')))
                        logger.info("Found and clicked 'Add appointment' button")
                    except (TimeoutException, NoSuchElementException):
                        logger.error("Cannot find slot booking table or button")
                        time.sleep(refresh_interval)
                        continue

                # Dynamically search for all date headers and then matching time slots
                all_rows = WebDriverWait(driver, 5).until(
                    EC.presence_of_all_elements_located((By.CSS_SELECTOR, "table#slotbookertable tr"))
                )
                
                # For debugging
                page_source = driver.page_source
                logger.debug(f"Number of rows found: {len(all_rows)}")
                
                # Look for date headers first
                date_headers = []
                for i, row in enumerate(all_rows):
                    row_text = row.text.strip()
                    # Look for date patterns in the row
                    date_header_match = re.search(r'\b(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},\s+\d{4}\b', row_text)
                    
                    if date_header_match:
                        date_header_text = date_header_match.group(0).strip()
                        # Check if this date header matches any of our expected formats
                        if any(expected in date_header_text for expected in expected_date_formats):
                            date_headers.append((i, date_header_text))
                            logger.info(f"Found matching date header: {date_header_text} at row {i}")
                
                # Now process rows following each date header
                for header_row_idx, header_text in date_headers:
                    # Process rows below the header until the next header or end of table
                    for row_idx in range(header_row_idx + 1, len(all_rows)):
                        if row_idx >= len(all_rows):
                            break
                            
                        row = all_rows[row_idx]
                        row_text = row.text.strip()
                        
                        # Skip empty rows or rows that look like headers
                        if not row_text or "Day" in row_text or any(day in row_text for day in days_of_week):
                            continue
                            
                        # Check if this row contains our target times
                        if start_time in row_text and end_time in row_text:
                            logger.info(f"Found row with target times: {row_text}")
                            
                            # Check if slot is already booked
                            if "Booked" in row_text or "Unavailable" in row_text:
                                logger.info("Slot already booked or unavailable, skipping...")
                                continue
                                
                            try:
                                # Find and click the Book slot button
                                book_buttons = row.find_elements(By.XPATH, ".//button[contains(text(), 'Book slot') or contains(text(), 'Book this slot')]")
                                if book_buttons:
                                    book_button = book_buttons[0]
                                    driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", book_button)
                                    time.sleep(0.5)  # Small delay for scroll to complete
                                    
                                    # Try to click with both approaches
                                    try:
                                        WebDriverWait(driver, 3).until(EC.element_to_be_clickable((By.XPATH, f"//button[contains(text(), 'Book slot') or contains(text(), 'Book this slot')]")))
                                        book_button.click()
                                    except ElementClickInterceptedException:
                                        driver.execute_script("arguments[0].click();", book_button)
                                        
                                    logger.info("Clicked Book slot button")
                                    
                                    # Fill note and submit
                                    try:
                                        # Wait for the note field - handle both possible IDs
                                        try:
                                            note_field = WebDriverWait(driver, 5).until(
                                                EC.visibility_of_element_located((By.ID, "id_studentnote_editoreditable"))
                                            )
                                        except TimeoutException:
                                            try:
                                                note_field = WebDriverWait(driver, 3).until(
                                                    EC.visibility_of_element_located((By.ID, "id_appointmentnote_editoreditable"))
                                                )
                                            except TimeoutException:
                                                # Try any editor field as last resort
                                                note_field = WebDriverWait(driver, 3).until(
                                                    EC.visibility_of_element_located((By.CSS_SELECTOR, "[contenteditable='true']"))
                                                )
                                                
                                        note_field.send_keys("Booking for project work")
                                        logger.info("Entered booking note")
                                        
                                        # Look for the submit button with various possible IDs or text
                                        submit_buttons = driver.find_elements(By.XPATH, "//input[@type='submit' and @value='Save'] | //button[contains(text(), 'Save changes')] | //button[@id='id_submitbutton']")
                                        
                                        if submit_buttons:
                                            submit_button = submit_buttons[0]
                                            driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", submit_button)
                                            time.sleep(0.5)
                                            
                                            try:
                                                submit_button.click()
                                            except ElementClickInterceptedException:
                                                driver.execute_script("arguments[0].click();", submit_button)
                                                
                                            logger.info("Clicked Submit button")
                                            
                                            # Check for confirmation with multiple possible indicators
                                            try:
                                                confirmation = WebDriverWait(driver, 8).until(
                                                    EC.presence_of_element_located((By.XPATH, 
                                                        "//*[contains(text(), 'Booking confirmed') or contains(text(), 'Appointment saved') or contains(text(), 'Your appointment has been scheduled')]"))
                                                )
                                                found_slot = True
                                                logger.info(f"Slot booked successfully! Confirmation: {confirmation.text}")
                                                
                                                # Add to booking history
                                                booking_details = {
                                                    "date": date,
                                                    "day": day,
                                                    "start_time": start_time,
                                                    "end_time": end_time,
                                                    "booked_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                    "scheduler": combo_schedule.get()
                                                }
                                                booking_history.append(booking_details)
                                                save_booking_history()
                                                
                                                # Update UI
                                                root.after(0, lambda: show_notification("Success", f"✅ Slot booked: {day}, {date}, {start_time}-{end_time}"))
                                                root.after(0, update_history_listbox)
                                                
                                                if SOUND_AVAILABLE:
                                                    try:
                                                        playsound('success.wav')
                                                    except Exception as e:
                                                        logger.error(f"Failed to play sound: {e}")
                                                return
                                            except TimeoutException:
                                                # Check if we're back at the scheduler page, which also indicates success
                                                try:
                                                    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, 'slotbookertable')))
                                                    found_slot = True
                                                    logger.info("Back at scheduler page, assuming slot was booked successfully")
                                                    
                                                    # Add to booking history
                                                    booking_details = {
                                                        "date": date,
                                                        "day": day,
                                                        "start_time": start_time,
                                                        "end_time": end_time,
                                                        "booked_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                        "scheduler": combo_schedule.get()
                                                    }
                                                    booking_history.append(booking_details)
                                                    save_booking_history()
                                                    
                                                    # Update UI
                                                    root.after(0, lambda: show_notification("Success", f"✅ Slot booked: {day}, {date}, {start_time}-{end_time}"))
                                                    root.after(0, update_history_listbox)
                                                    
                                                    if SOUND_AVAILABLE:
                                                        try:
                                                            playsound('success.wav')
                                                        except Exception as e:
                                                            logger.error(f"Failed to play sound: {e}")
                                                    return
                                                except TimeoutException:
                                                    logger.warning("Could not confirm booking success")
                                        else:
                                            logger.warning("Submit button not found")
                                    except (NoSuchElementException, TimeoutException) as e:
                                        logger.error(f"Error during form submission: {e}")
                                else:
                                    logger.warning("Book slot button not found")
                            except Exception as e:
                                logger.error(f"Error processing row with target times: {e}")
                
                # If we get here, we didn't find a bookable slot matching our criteria
                logger.info(f"No bookable slot found on attempt {attempt}")
                
                # Adaptive refresh interval based on continuous mode
                if continuous:
                    # Use longer intervals for continuous mode to reduce server load
                    refresh_interval = random.uniform(5, 15)
                else:
                    # Use shorter intervals for immediate booking attempts
                    refresh_interval = random.uniform(1, 3)
                    
                time.sleep(refresh_interval)
                
            except StaleElementReferenceException:
                logger.warning("Stale element encountered, refreshing...")
                driver.refresh()
                time.sleep(1)
            except Exception as e:
                logger.error(f"Unexpected error during slot search: {e}")
                time.sleep(refresh_interval)

        if not found_slot and is_running:
            logger.warning(f"No slot found after {attempt} attempts.")
            root.after(0, lambda: show_notification("No Slot Found", f"❌ No matching slot found for {day}, {date}, {start_time}-{end_time} after {attempt} retries.", is_error=True))
            root.after(0, lambda: status_label.config(text=f"Status: No slot found after {attempt} attempts"))

    except TimeoutException as e:
        logger.error(f"Timeout error: {e}")
        root.after(0, lambda: show_notification("Error", f"❌ Timeout error during booking process", is_error=True))
    except NoSuchElementException as e:
        logger.error(f"Element not found: {e}")
        root.after(0, lambda: show_notification("Error", f"❌ Element not found: {str(e)[:100]}...", is_error=True))
    except WebDriverException as e:
        logger.error(f"WebDriver error: {e}")
        root.after(0, lambda: show_notification("Error", f"❌ Browser error: {str(e)[:100]}...", is_error=True))
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        root.after(0, lambda: show_notification("Error", f"❌ Unexpected error: {str(e)[:100]}...", is_error=True))
    finally:
        if driver:
            logger.info("Closing browser gracefully")
            if driver in active_drivers:
                active_drivers.remove(driver)
            try:
                driver.quit()
            except Exception as e:
                logger.error(f"Error while closing driver: {e}")

def add_slot():
    date = entry_date.get()
    try:
        date_obj = datetime.strptime(date.strip(), "%d %m %Y")
        day = date_obj.strftime("%A")
        combo_day.set(day)
    except ValueError:
        show_notification("Invalid Date", "Please enter a valid date in DD MM YYYY format.", is_error=True)
        return

    start_time = entry_start_time.get()
    end_time = entry_end_time.get()
    if not all([day, date, start_time, end_time]):
        show_notification("Input Missing", "Please fill in all slot fields.", is_error=True)
        return
        
    # Validate that end time is after start time
    try:
        start_dt = datetime.strptime(start_time, "%I:%M %p")
        end_dt = datetime.strptime(end_time, "%I:%M %p")
        if end_dt <= start_dt:
            show_notification("Invalid Time", "End time must be after start time.", is_error=True)
            return
    except ValueError:
        pass  # Continue if time format is different
        
    slot = {"day": day, "date": date, "start_time": start_time, "end_time": end_time}
    
    # Check for duplicates
    if any(s["date"] == date and s["start_time"] == start_time and s["end_time"] == end_time for s in slot_list):
        show_notification("Duplicate Slot", "This slot is already in your list.", is_error=True)
        return
        
    slot_list.append(slot)
    slot_str = f"Day: {day}, Date: {date}, Time: {start_time} - {end_time}"
    listbox_slots.insert(tk.END, slot_str)
    save_slots()

def remove_slot():
    selected = listbox_slots.curselection()
    if selected:
        index = selected[0]
        listbox_slots.delete(index)
        slot_list.pop(index)
        save_slots()

def stop_process():
    global is_running
    # Set flag to stop all processes
    is_running = False
    
    # Clear all scheduled jobs
    schedule.clear()
    global scheduled_time
    scheduled_time = None
    logger.info("All scheduled jobs cleared.")

    # Stop all active threads and drivers
    for driver in active_drivers[:]:
        try:
            driver.quit()
            active_drivers.remove(driver)
            logger.info("Closed an active browser instance.")
        except Exception as e:
            logger.error(f"Error closing driver: {e}")

    for thread in active_threads[:]:
        try:
            active_threads.remove(thread)
            logger.info("Removed a tracked thread.")
        except Exception as e:
            logger.error(f"Error removing thread: {e}")

    show_notification("Stopped", "All booking processes and schedules have been stopped.")
    status_label.config(text="Status: Stopped")

def run_booking(continuous=False):
    global is_running
    is_running = True
    global scheduled_time
    
    # If scheduled, validate the current time
    if scheduled_time and not continuous:
        now = datetime.now()
        scheduled = datetime.strptime(scheduled_time, "%H:%M")
        scheduled_today = now.replace(hour=scheduled.hour, minute=scheduled.minute, second=0, microsecond=0)
        time_diff = abs((now - scheduled_today).total_seconds())
        if time_diff > 60:  # Allow 1-minute window
            logger.info(f"Booking attempt ignored: Current time {now.strftime('%H:%M:%S')} is not within 1 minute of scheduled time {scheduled_time}")
            return

    username = entry_username.get()
    password = entry_password.get()
    
    # Validate inputs
    if not username or not password:
        show_notification("Missing Credentials", "Please enter your username and password.", is_error=True)
        return
        
    choice = combo_schedule.get()
    browser_choice = combo_browser.get()
    headless_mode = headless_var.get()
    proxies = entry_proxies.get().split(",") if entry_proxies.get() else []
    proxies = [p.strip() for p in proxies if p.strip()]

    urls = {
        "1731": "https://lms2.ai.saveetha.in/mod/scheduler/view.php?id=36638",
        "1851": "https://lms2.ai.saveetha.in/mod/scheduler/view.php?id=36298",
        "1852": "https://lms2.ai.saveetha.in/mod/scheduler/view.php?id=37641",
        "1611": "https://lms2.ai.saveetha.in/mod/scheduler/view.php?id=36137"
    }

    if choice not in urls:
        show_notification("Error", "Invalid schedule selected.", is_error=True)
        return
    if not slot_list:
        show_notification("No Slots", "Please add at least one slot to book.", is_error=True)
        return

    scheduler_url = urls[choice]

    logger.info(f"Starting booking process at {datetime.now().strftime('%H:%M:%S')}...")
    status_label.config(text=f"Status: Booking process started at {datetime.now().strftime('%H:%M:%S')}")
    
    # Sort slots by date if continuous mode to prioritize earliest slots
    if continuous:
        sorted_slots = sorted(slot_list, key=lambda x: datetime.strptime(x["date"].strip(), "%d %m %Y"))
    else:
        sorted_slots = slot_list
        
    for i, slot in enumerate(sorted_slots):
        if not is_running:
            break
            
        proxy = proxies[i % len(proxies)] if proxies else None
        thread = threading.Thread(target=slot_booking_process, args=(
            username, password, slot["day"], slot["date"], slot["start_time"], slot["end_time"],
            scheduler_url, proxy, headless_mode, browser_choice, root, continuous
        ))
        active_threads.append(thread)
        thread.start()
        
        # Add a small delay between thread starts to avoid overwhelming the system
        time.sleep(0.5)

def schedule_booking():
    global scheduled_time
    schedule_time = entry_schedule_time.get()
    try:
        # Validate time format (e.g., "21:03")
        datetime.strptime(schedule_time, "%H:%M")
        # Clear all previous scheduled jobs
        schedule.clear()
        # Store the scheduled time
        scheduled_time = schedule_time
        # Schedule the booking
        schedule.every().day.at(schedule_time).do(lambda: run_booking(continuous=True))
        logger.info(f"Scheduled booking daily at {schedule_time}")
        show_notification("Scheduled", f"Booking scheduled daily at {schedule_time}. Next run: {schedule.next_run().strftime('%Y-%m-%d %H:%M:%S')}.")
        status_label.config(text=f"Status: Scheduled at {schedule_time}")

        # Start schedule loop in a separate thread
        def run_schedule():
            while True:
                now = datetime.now()
                next_run = schedule.next_run()
                if next_run:
                    time_to_next = (next_run - now).total_seconds()
                    # Update status every minute
                    if int(time_to_next) % 60 == 0:
                        mins_to_next = int(time_to_next / 60)
                        root.after(0, lambda m=mins_to_next: status_label.config(text=f"Status: Scheduled | Next run in {m} minutes"))
                        logger.info(f"Next scheduled run at {next_run.strftime('%H:%M:%S')} ({mins_to_next} minutes from now)")
                schedule.run_pending()
                time.sleep(30)
        scheduling_thread = threading.Thread(target=run_schedule, daemon=True)
        scheduling_thread.start()
        active_threads.append(scheduling_thread)
    except ValueError:
        show_notification("Error", "Invalid time format. Use HH:MM (e.g., 21:03).", is_error=True)

def on_date_selected(event=None):
    date = entry_date.get()
    try:
        date_obj = datetime.strptime(date.strip(), "%d %m %Y")
        day = date_obj.strftime("%A")
        combo_day.set(day)
    except ValueError:
        combo_day.set("")

def on_schedule_selected(event=None):
    schedule_id = combo_schedule.get()
    times = venue_time_slots.get(schedule_id, [])
    entry_start_time['values'] = times
    entry_end_time['values'] = times
    if times:
        entry_start_time.set(times[0])
        entry_end_time.set(times[-1])
    else:
        entry_start_time.set("")
        entry_end_time.set("")

def save_slots():
    """Save slot list to config file"""
    config = load_config()
    config['slots'] = slot_list
    save_config(config)

def save_credentials():
    """Save credentials to config file if remember_credentials is checked"""
    if remember_var.get():
        config = load_config()
        config['username'] = entry_username.get()
        config['password'] = entry_password.get()  # Note: passwords stored in plain text - not secure
        config['remember_credentials'] = True
    else:
        config = load_config()
        config.pop('username', None)
        config.pop('password', None)
        config['remember_credentials'] = False
    save_config(config)

def save_settings():
    """Save current settings to config file"""
    config = load_config()
    config['browser'] = combo_browser.get()
    config['schedule'] = combo_schedule.get()
    config['headless'] = headless_var.get()
    config['proxies'] = entry_proxies.get()
    config['notification'] = notification_var.get()
    config['theme'] = theme_var.get()
    config['retry_count'] = retry_count_var.get()
    save_config(config)
    show_notification("Settings Saved", "Your settings have been saved successfully.")

def save_config(config):
    """Save configuration to file"""
    try:
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=4)
    except Exception as e:
        logger.error(f"Error saving configuration: {e}")

def load_config():
    """Load configuration from file or return defaults"""
    try:
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                return json.load(f)
    except Exception as e:
        logger.error(f"Error loading configuration: {e}")
    return {}  # Return empty dict if file doesn't exist or is invalid

def save_booking_history():
    """Save booking history to file"""
    config = load_config()
    config['booking_history'] = booking_history
    save_config(config)

def load_booking_history():
    """Load booking history from config"""
    global booking_history
    config = load_config()
    booking_history = config.get('booking_history', [])
    update_history_listbox()

def update_history_listbox():
    """Update the booking history listbox"""
    if hasattr(root, 'history_listbox'):
        history_listbox.delete(0, tk.END)
        for booking in booking_history:
            history_listbox.insert(tk.END, f"{booking['date']} ({booking['day']}): {booking['start_time']}-{booking['end_time']} ({booking['scheduler']})")

def load_saved_data():
    """Load all saved data from config file"""
    global slot_list
    config = load_config()
    
    # Load slots
    slot_list = config.get('slots', [])
    listbox_slots.delete(0, tk.END)
    for slot in slot_list:
        slot_str = f"Day: {slot['day']}, Date: {slot['date']}, Time: {slot['start_time']} - {slot['end_time']}"
        listbox_slots.insert(tk.END, slot_str)
    
    # Load credentials if remember is enabled
    if config.get('remember_credentials', False):
        username = config.get('username', '')
        password = config.get('password', '')
        if username:
            entry_username.delete(0, tk.END)
            entry_username.insert(0, username)
        if password:
            entry_password.delete(0, tk.END)
            entry_password.insert(0, password)
        remember_var.set(True)
    
    # Load other settings
    browser = config.get('browser', 'Chrome')
    if browser in combo_browser['values']:
        combo_browser.set(browser)
        
    schedule_id = config.get('schedule', '1731')
    if schedule_id in combo_schedule['values']:
        combo_schedule.set(schedule_id)
        on_schedule_selected()
        
    headless_var.set(config.get('headless', False))
    proxies = config.get('proxies', '')
    if proxies:
        entry_proxies.delete(0, tk.END)
        entry_proxies.insert(0, proxies)
        
    notification_var.set(config.get('notification', True))
    theme_var.set(config.get('theme', 'System'))
    retry_count_var.set(config.get('retry_count', 5))
    
    # Load booking history
    load_booking_history()

def export_slots():
    """Export slots to a JSON file"""
    file_path = filedialog.asksaveasfilename(
        defaultextension=".json",
        filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
    )
    if file_path:
        try:
            with open(file_path, 'w') as f:
                json.dump(slot_list, f, indent=4)
            show_notification("Export Successful", f"Slots exported to {file_path}")
        except Exception as e:
            show_notification("Export Failed", f"Error exporting slots: {str(e)}", is_error=True)

def import_slots():
    """Import slots from a JSON file"""
    file_path = filedialog.askopenfilename(
        defaultextension=".json",
        filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
    )
    if file_path:
        try:
            with open(file_path, 'r') as f:
                imported_slots = json.load(f)
                
            if not isinstance(imported_slots, list):
                show_notification("Import Failed", "Invalid format in imported file", is_error=True)
                return
                
            # Validate slot format
            valid_slots = []
            for slot in imported_slots:
                if isinstance(slot, dict) and all(k in slot for k in ["day", "date", "start_time", "end_time"]):
                    valid_slots.append(slot)
                    
            global slot_list
            slot_list = valid_slots
            
            # Update listbox
            listbox_slots.delete(0, tk.END)
            for slot in slot_list:
                slot_str = f"Day: {slot['day']}, Date: {slot['date']}, Time: {slot['start_time']} - {slot['end_time']}"
                listbox_slots.insert(tk.END, slot_str)
                
            save_slots()
            show_notification("Import Successful", f"Imported {len(valid_slots)} slots")
            
        except Exception as e:
            show_notification("Import Failed", f"Error importing slots: {str(e)}", is_error=True)

def change_theme(event=None):
    """Change application theme"""
    theme = theme_var.get()
    try:
        if theme == "Light":
            root.config(bg="#f0f0f0")
            style.theme_use('clam')
        elif theme == "Dark":
            root.config(bg="#2d2d2d")
            style.configure("TFrame", background="#2d2d2d")
            style.configure("TButton", background="#3d3d3d", foreground="white")
            style.configure("TLabel", background="#2d2d2d", foreground="white")
            style.configure("TCheckbutton", background="#2d2d2d", foreground="white")
            style.configure("TNotebook", background="#2d2d2d")
            style.configure("TNotebook.Tab", background="#3d3d3d", foreground="white")
        else:  # System default
            root.config(bg=root_bg)
            style.theme_use('clam')
        save_settings()
    except Exception as e:
        logger.error(f"Error changing theme: {e}")

def test_connection():
    """Test connection to LMS website"""
    browser_choice = combo_browser.get()
    driver = None
    try:
        if browser_choice == "Chrome":
            options = ChromeOptions()
            options.add_argument("--headless=new")
            driver = webdriver.Chrome(options=options)
        elif browser_choice == "Firefox":
            options = FirefoxOptions()
            options.add_argument("--headless")
            driver = webdriver.Firefox(options=options)
        elif browser_choice == "Edge":
            options = EdgeOptions()
            options.add_argument("--headless")
            driver = webdriver.Edge(options=options)
        
        start_time = time.time()
        driver.get("https://lms2.ai.saveetha.in/")
        load_time = time.time() - start_time
        
        if "Saveetha" in driver.title:
            show_notification("Connection Test", f"Successfully connected to LMS. Page load time: {load_time:.2f} seconds")
        else:
            show_notification("Connection Test", "Connected to server but couldn't verify LMS page", is_error=True)
            
    except Exception as e:
        show_notification("Connection Failed", f"Could not connect to LMS: {str(e)}", is_error=True)
    finally:
        if driver:
            driver.quit()

def update_notification_state():
    """Update notification state based on checkbox"""
    global notification_enabled
    notification_enabled = notification_var.get()
    save_settings()

def generate_quick_slots():
    """Generate slots for the next week"""
    try:
        # Clear current slots
        listbox_slots.delete(0, tk.END)
        global slot_list
        slot_list = []
        
        # Get selected venue times
        schedule_id = combo_schedule.get()
        times = venue_time_slots.get(schedule_id, [])
        if not times:
            show_notification("Error", "No times available for this venue", is_error=True)
            return
            
        # Generate slots for the next 7 days
        today = datetime.now()
        for i in range(1, 8):  # Next 7 days
            day_date = today + timedelta(days=i)
            day_name = day_date.strftime("%A")
            date_str = day_date.strftime("%d %m %Y")
            
            # Skip weekends if checkbox is checked
            if skip_weekends_var.get() and day_name in ["Saturday", "Sunday"]:
                continue
                
            # Add morning and afternoon slots
            if len(times) >= 2:
                # Morning slot
                slot = {
                    "day": day_name,
                    "date": date_str,
                    "start_time": times[0],
                    "end_time": times[1]
                }
                slot_list.append(slot)
                slot_str = f"Day: {day_name}, Date: {date_str}, Time: {times[0]} - {times[1]}"
                listbox_slots.insert(tk.END, slot_str)
                
                # Afternoon slot if available
                if len(times) >= 4:
                    slot = {
                        "day": day_name,
                        "date": date_str,
                        "start_time": times[2],
                        "end_time": times[3]
                    }
                    slot_list.append(slot)
                    slot_str = f"Day: {day_name}, Date: {date_str}, Time: {times[2]} - {times[3]}"
                    listbox_slots.insert(tk.END, slot_str)
        
        save_slots()
        show_notification("Quick Slots", f"Generated {len(slot_list)} slots for the next week")
        
    except Exception as e:
        show_notification("Error", f"Failed to generate quick slots: {str(e)}", is_error=True)

def clear_history():
    """Clear booking history"""
    global booking_history
    if messagebox.askyesno("Clear History", "Are you sure you want to clear your booking history?"):
        booking_history = []
        save_booking_history()
        update_history_listbox()
        show_notification("History Cleared", "Your booking history has been cleared")

def check_for_dependencies():
    """Check if all required dependencies are installed"""
    missing_dependencies = []
    
    # Check for required packages
    try:
        import selenium
    except ImportError:
        missing_dependencies.append("selenium")
        
    try:
        import tkcalendar
    except ImportError:
        missing_dependencies.append("tkcalendar")
        
    try:
        import schedule
    except ImportError:
        missing_dependencies.append("schedule")
    
    # Optional dependencies
    if not SOUND_AVAILABLE:
        logger.info("playsound not installed - sound notifications will be disabled")
        
    if not GPU_AVAILABLE:
        logger.info("GPUtil not installed - GPU acceleration checks will be disabled")
    
    if missing_dependencies:
        message = f"Missing required dependencies: {', '.join(missing_dependencies)}\n\n"
        message += "Please install them using pip:\n"
        message += f"pip install {' '.join(missing_dependencies)}"
        messagebox.showerror("Missing Dependencies", message)
        return False
    
    return True

# --- Define days of week for validation ---
days_of_week = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

# --- GUI Layout ---
root = tk.Tk()
root.title("Enhanced Slot Booking Bot v2.0 - Saveetha LMS")
root.geometry("680x700")  # Wider window for better layout
root_bg = root.cget("background")  # Store default background for theme changes

# Create a style object for ttk widgets
style = ttk.Style()

# Create variables for settings
theme_var = tk.StringVar(value="System")
notification_var = tk.BooleanVar(value=True)
remember_var = tk.BooleanVar(value=False)
retry_count_var = tk.IntVar(value=5)
headless_var = tk.BooleanVar(value=False)
skip_weekends_var = tk.BooleanVar(value=True)

# --- Time slots for each venue ---
venue_time_slots = {
    "1731": ["8:00 AM", "10:00 AM", "12:00 PM", "2:00 PM", "4:00 PM"],
    "1851": ["9:00 AM", "11:00 AM", "1:00 PM", "3:00 PM"],
    "1852": ["7:00 AM", "9:00 AM", "11:00 AM", "1:00 PM"],
    "1611": ["10:00 AM", "12:00 PM", "2:00 PM", "4:00 PM"]
}

# Create a notebook for tabbed interface
notebook = ttk.Notebook(root)
notebook.pack(fill='both', expand=True, padx=10, pady=10)

# Main tab
main_tab = ttk.Frame(notebook)
notebook.add(main_tab, text="Main")

# Settings tab
settings_tab = ttk.Frame(notebook)
notebook.add(settings_tab, text="Settings")

# History tab
history_tab = ttk.Frame(notebook)
notebook.add(history_tab, text="History")

# About tab
about_tab = ttk.Frame(notebook)
notebook.add(about_tab, text="About")

# --- Main tab ---
main_frame = ttk.LabelFrame(main_tab, text="Credentials")
main_frame.pack(fill='x', padx=10, pady=10)

cred_frame = ttk.Frame(main_frame)
cred_frame.pack(fill='x', padx=10, pady=5)

ttk.Label(cred_frame, text="Username").grid(row=0, column=0, sticky='w', padx=5, pady=5)
entry_username = ttk.Entry(cred_frame, width=30)
entry_username.grid(row=0, column=1, padx=5, pady=5)

ttk.Label(cred_frame, text="Password").grid(row=1, column=0, sticky='w', padx=5, pady=5)
entry_password = ttk.Entry(cred_frame, width=30, show="*")
entry_password.grid(row=1, column=1, padx=5, pady=5)

remember_check = ttk.Checkbutton(cred_frame, text="Remember credentials", variable=remember_var, command=save_credentials)
remember_check.grid(row=2, column=1, sticky='w', padx=5, pady=5)

schedule_frame = ttk.LabelFrame(main_tab, text="Schedule Settings")
schedule_frame.pack(fill='x', padx=10, pady=10)

ttk.Label(schedule_frame, text="Select Venue").grid(row=0, column=0, sticky='w', padx=5, pady=5)
combo_schedule = ttk.Combobox(schedule_frame, values=["1731", "1851", "1852", "1611"], state="readonly", width=10)
combo_schedule.grid(row=0, column=1, sticky='w', padx=5, pady=5)
combo_schedule.set("1731")

ttk.Label(schedule_frame, text="Browser").grid(row=0, column=2, sticky='w', padx=5, pady=5)
combo_browser = ttk.Combobox(schedule_frame, values=["Chrome", "Firefox", "Edge"], state="readonly", width=10)
combo_browser.grid(row=0, column=3, sticky='w', padx=5, pady=5)
combo_browser.set("Chrome")

ttk.Label(schedule_frame, text="Run Headless").grid(row=1, column=0, sticky='w', padx=5, pady=5)
headless_check = ttk.Checkbutton(schedule_frame, text="Enable", variable=headless_var)
headless_check.grid(row=1, column=1, sticky='w', padx=5, pady=5)

ttk.Label(schedule_frame, text="Retry Count").grid(row=1, column=2, sticky='w', padx=5, pady=5)
retry_spin = ttk.Spinbox(schedule_frame, from_=1, to=20, textvariable=retry_count_var, width=5)
retry_spin.grid(row=1, column=3, sticky='w', padx=5, pady=5)

ttk.Label(schedule_frame, text="Proxies (comma-separated)").grid(row=2, column=0, columnspan=2, sticky='w', padx=5, pady=5)
entry_proxies = ttk.Entry(schedule_frame, width=50)
entry_proxies.grid(row=2, column=1, columnspan=3, sticky='w', padx=5, pady=5)

ttk.Label(schedule_frame, text="Schedule Time (HH:MM)").grid(row=3, column=0, sticky='w', padx=5, pady=5)
entry_schedule_time = ttk.Entry(schedule_frame, width=10)
entry_schedule_time.grid(row=3, column=1, sticky='w', padx=5, pady=5)
entry_schedule_time.insert(0, "21:00")

slot_frame = ttk.LabelFrame(main_tab, text="Slot Configuration")
slot_frame.pack(fill='both', expand=True, padx=10, pady=10)

date_frame = ttk.Frame(slot_frame)
date_frame.pack(fill='x', padx=5, pady=5)

ttk.Label(date_frame, text="Date (DD MM YYYY)").grid(row=0, column=0, sticky='w', padx=5, pady=5)
entry_date = DateEntry(date_frame, width=15, date_pattern="dd mm yyyy")
entry_date.grid(row=0, column=1, sticky='w', padx=5, pady=5)

ttk.Label(date_frame, text="Day").grid(row=0, column=2, sticky='w', padx=5, pady=5)
combo_day = ttk.Combobox(date_frame, values=days_of_week, state="readonly", width=10)
combo_day.grid(row=0, column=3, sticky='w', padx=5, pady=5)

ttk.Label(date_frame, text="Start Time").grid(row=1, column=0, sticky='w', padx=5, pady=5)
entry_start_time = ttk.Combobox(date_frame, values=[], state="readonly", width=15)
entry_start_time.grid(row=1, column=1, sticky='w', padx=5, pady=5)

ttk.Label(date_frame, text="End Time").grid(row=1, column=2, sticky='w', padx=5, pady=5)
entry_end_time = ttk.Combobox(date_frame, values=[], state="readonly", width=15)
entry_end_time.grid(row=1, column=3, sticky='w', padx=5, pady=5)

button_frame = ttk.Frame(slot_frame)
button_frame.pack(fill='x', padx=5, pady=5)

button_add_slot = ttk.Button(button_frame, text="Add Slot", command=add_slot)
button_add_slot.grid(row=0, column=0, padx=5, pady=5)

button_remove_slot = ttk.Button(button_frame, text="Remove Selected", command=remove_slot)
button_remove_slot.grid(row=0, column=1, padx=5, pady=5)

button_generate_slots = ttk.Button(button_frame, text="Generate Week Slots", command=generate_quick_slots)
button_generate_slots.grid(row=0, column=2, padx=5, pady=5)

skip_weekends_check = ttk.Checkbutton(button_frame, text="Skip Weekends", variable=skip_weekends_var)
skip_weekends_check.grid(row=0, column=3, padx=5, pady=5)

button_import = ttk.Button(button_frame, text="Import", command=import_slots)
button_import.grid(row=0, column=4, padx=5, pady=5)

button_export = ttk.Button(button_frame, text="Export", command=export_slots)
button_export.grid(row=0, column=5, padx=5, pady=5)

slot_list_frame = ttk.Frame(slot_frame)
slot_list_frame.pack(fill='both', expand=True, padx=5, pady=5)

listbox_slots = tk.Listbox(slot_list_frame, height=5)
scrollbar = ttk.Scrollbar(slot_list_frame, orient="vertical", command=listbox_slots.yview)
listbox_slots.config(yscrollcommand=scrollbar.set)
listbox_slots.pack(side="left", fill="both", expand=True)
scrollbar.pack(side="right", fill="y")

action_frame = ttk.Frame(main_tab)
action_frame.pack(fill='x', padx=10, pady=10)

button_book = ttk.Button(action_frame, text="Book Slots Now", command=lambda: run_booking(continuous=False))
button_book.pack(side="left", padx=5, pady=5)

button_schedule = ttk.Button(action_frame, text="Schedule Booking", command=schedule_booking)
button_schedule.pack(side="left", padx=5, pady=5)

button_test = ttk.Button(action_frame, text="Test Connection", command=test_connection)
button_test.pack(side="left", padx=5, pady=5)

button_stop = ttk.Button(action_frame, text="Stop All Processes", command=stop_process)
button_stop.pack(side="left", padx=5, pady=5)

status_label = ttk.Label(main_tab, text="Status: Ready", relief="sunken", anchor="w")
status_label.pack(fill='x', padx=10, pady=10)

# --- Settings tab ---
settings_frame = ttk.LabelFrame(settings_tab, text="Application Settings")
settings_frame.pack(fill='both', expand=True, padx=10, pady=10)

ttk.Label(settings_frame, text="Theme:").grid(row=0, column=0, sticky='w', padx=10, pady=5)
theme_combo = ttk.Combobox(settings_frame, values=["System", "Light", "Dark"], 
                          textvariable=theme_var, state="readonly", width=10)
theme_combo.grid(row=0, column=1, sticky='w', padx=10, pady=5)
theme_combo.bind("<<ComboboxSelected>>", change_theme)

ttk.Label(settings_frame, text="Notifications:").grid(row=1, column=0, sticky='w', padx=10, pady=5)
notification_check = ttk.Checkbutton(settings_frame, text="Enable popup notifications", 
                                   variable=notification_var, command=update_notification_state)
notification_check.grid(row=1, column=1, sticky='w', padx=10, pady=5)

ttk.Label(settings_frame, text="Max Retries:").grid(row=2, column=0, sticky='w', padx=10, pady=5)
retry_spinbox = ttk.Spinbox(settings_frame, from_=1, to=20, textvariable=retry_count_var, width=5)
retry_spinbox.grid(row=2, column=1, sticky='w', padx=10, pady=5)

settings_button_frame = ttk.Frame(settings_tab)
settings_button_frame.pack(fill='x', padx=10, pady=10)

save_settings_button = ttk.Button(settings_button_frame, text="Save Settings", command=save_settings)
save_settings_button.pack(side="left", padx=5, pady=5)

# --- History tab ---
history_frame = ttk.Frame(history_tab)
history_frame.pack(fill='both', expand=True, padx=10, pady=10)

ttk.Label(history_frame, text="Booking History").pack(anchor='w', padx=5, pady=5)

history_listbox = tk.Listbox(history_frame, height=10)
history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=history_listbox.yview)
history_listbox.config(yscrollcommand=history_scrollbar.set)
history_listbox.pack(side="left", fill="both", expand=True)
history_scrollbar.pack(side="right", fill="y")

clear_history_button = ttk.Button(history_tab, text="Clear History", command=clear_history)
clear_history_button.pack(padx=10, pady=10)

# --- About tab ---
about_frame = ttk.Frame(about_tab)
about_frame.pack(fill='both', expand=True, padx=20, pady=20)

about_text = """
Enhanced Slot Booking Bot v2.0

This application automates the process of booking slots on the Saveetha LMS platform.

Features:
• Multiple browser support (Chrome, Firefox, Edge)
• Scheduled booking
• Session persistence
• Slot management (import/export)
• Booking history
• Theme customization
• GPU acceleration (when available)

Created by: Your Name

For support or feature requests, please contact: your.email@example.com
"""

about_label = ttk.Label(about_frame, text=about_text, justify='left', wraplength=500)
about_label.pack(padx=10, pady=10)

# Set up event bindings
entry_date.bind("<<DateEntrySelected>>", on_date_selected)
entry_date.bind("<FocusOut>", on_date_selected)
combo_schedule.bind("<<ComboboxSelected>>", on_schedule_selected)

# Set initial time slots
on_schedule_selected()

# Check dependencies at startup
if check_for_dependencies():
    # Load saved configuration
    load_saved_data()
    
    # Set theme
    change_theme()
    
    # Start the main loop
    root.mainloop()
